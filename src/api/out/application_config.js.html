<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CloudBrowser Source: application_config.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.readable.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">CloudBrowser</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="cloudbrowser.html">cloudbrowser</a>
						</li>
						
						<li>
							<a href="cloudbrowser.app.html">app</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="AppConfig.html">AppConfig</a>
						</li>
						
						<li>
							<a href="cloudbrowser.app.User.html">User</a>
						</li>
						
						<li>
							<a href="GoogleStrategy.html">GoogleStrategy</a>
						</li>
						
						<li>
							<a href="LocalStrategy.html">LocalStrategy</a>
						</li>
						
						<li>
							<a href="ServerConfig.html">ServerConfig</a>
						</li>
						
						<li>
							<a href="SharedState.html">SharedState</a>
						</li>
						
						<li>
							<a href="Util.html">Util</a>
						</li>
						
						<li>
							<a href="VirtualBrowser.html">VirtualBrowser</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="AppConfig.html#event:Add">Add</a>
						</li>
						
						<li>
							<a href="AppConfig.html#event:Remove">Remove</a>
						</li>
						
						<li>
							<a href="SharedState.html#event:addBrowser">addBrowser</a>
						</li>
						
						<li>
							<a href="SharedState.html#event:removeBrowser">removeBrowser</a>
						</li>
						
						<li>
							<a href="SharedState.html#event:rename">rename</a>
						</li>
						
						<li>
							<a href="SharedState.html#event:share">share</a>
						</li>
						
						<li>
							<a href="VirtualBrowser.html#event:rename">rename</a>
						</li>
						
						<li>
							<a href="VirtualBrowser.html#event:share">share</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: application_config.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript linenums">// Generated by CoffeeScript 1.6.3
(function() {
  var AppConfig, Async, SharedState, cloudbrowserError,
    __slice = [].slice;

  Async = require('async');

  SharedState = require('./shared_state');

  cloudbrowserError = require('../shared/cloudbrowser_error');

  /**
      A new browser of the current application has been added
      @event AppConfig#Add
      @type {VirtualBrowser}
  */


  /**
      A new browser of the current application has been removed
      @event AppConfig#Remove
      @type {Number}
  */


  /**
      API for applications (constructed internally).
      Provides access to application configuration details.
      @param {Object}        options 
      @param {Application}  [options.app]   The application.
      @param {Cloudbrowser} [options.cbCtx] The cloudbrowser API object.
      @param {cloudbrowser.app.User} [options.userCtx] The current user.
      @class AppConfig
      @fires AppConfig#Add
      @fires AppConfig#Remove
  */


  AppConfig = (function() {
    var _pvts;

    _pvts = [];

    function AppConfig(options) {
      var app, cbCtx, userCtx;
      app = options.app, userCtx = options.userCtx, cbCtx = options.cbCtx;
      Object.defineProperty(this, "_idx", {
        value: _pvts.length
      });
      _pvts.push({
        app: app.parent != null ? app.parent : app,
        cbCtx: cbCtx,
        userCtx: userCtx
      });
      Object.freeze(this.__proto__);
      Object.freeze(this);
    }

    /**
        Checks if the current user is the owner of the application
        @method isOwner
        @memberof AppConfig
        @instance
        @param {cloudbrowser.app.User} user
        @param {booleanCallback} callback
    */


    AppConfig.prototype.isOwner = function(callback) {
      var app, permissionManager, userCtx, _ref;
      if (typeof callback !== "function") {
        return;
      }
      _ref = _pvts[this._idx], app = _ref.app, userCtx = _ref.userCtx;
      permissionManager = app.server.permissionManager;
      return permissionManager.checkPermissions({
        user: userCtx.toJson(),
        mountPoint: app.getMountPoint(),
        permissions: {
          'own': true
        },
        callback: callback
      });
    };

    /**
        Gets the absolute URL at which the application is hosted/mounted.
        @instance
        @method getUrl
        @memberOf AppConfig
        @returns {String}
    */


    AppConfig.prototype.getUrl = function() {
      var app, domain, port, _ref;
      app = _pvts[this._idx].app;
      _ref = app.server.config, domain = _ref.domain, port = _ref.port;
      return "http://" + domain + ":" + port + (app.getMountPoint());
    };

    /**
        Gets the description of the application as provided in the
        deployment_config.json configuration file.    
        @instance
        @method getDescription
        @memberOf AppConfig
        @return {String}
    */


    AppConfig.prototype.getDescription = function() {
      return _pvts[this._idx].app.getDescription();
    };

    /**
        Wraps all calls on the application object with a permission check
        @instance
        @private
        @method _call
        @memberOf AppConfig
        @param {String} method
        @param {Function} callback
        @param {...String} args
    */


    AppConfig.prototype._call = function() {
      var app, args, callback, method, validMethods,
        _this = this;
      method = arguments[0], callback = arguments[1], args = 3 &lt;= arguments.length ? __slice.call(arguments, 2) : [];
      if (typeof callback !== "function") {
        return;
      }
      if (typeof method !== "string") {
        callback(cloudbrowserError('PARAM_MISSING', '- method'));
      }
      validMethods = ['mount', 'disable', 'makePublic', 'makePrivate', 'setDescription', 'enableAuthentication', 'disableAuthentication', 'setBrowserLimit'];
      if (validMethods.indexOf(method) === -1) {
        return;
      }
      app = _pvts[this._idx].app;
      return Async.waterfall([
        function(next) {
          return _this.isOwner(next);
        }
      ], function(err, isOwner) {
        if (err) {
          return callback(err);
        } else if (!isOwner) {
          return callback(cloudbrowserError("PERM_DENIED"));
        } else {
          app[method].apply(app, args);
          return callback(null);
        }
      });
    };

    /**
        Sets the description of the application in the deployment_config.json
        configuration file.    
        @instance
        @method setDescription
        @memberOf AppConfig
        @param {String} Description
        @param {booleanCallback} callback
    */


    AppConfig.prototype.setDescription = function(description, callback) {
      if (typeof description !== "string") {
        return typeof callback === "function" ? callback(cloudbrowserError('PARAM_MISSING', '- description')) : void 0;
      } else {
        callback = callback || (function() {});
        return this._call('setDescription', callback, description);
      }
    };

    /**
        Gets the path relative to the root URL at which the application
        was mounted.
        @instance
        @method getMountPoint
        @memberOf AppConfig
        @return {String}
    */


    AppConfig.prototype.getMountPoint = function() {
      return _pvts[this._idx].app.getMountPoint();
    };

    /**
        Checks if the application is configured as publicly visible.
        @instance
        @method isAppPublic
        @memberOf AppConfig
        @return {Bool}
    */


    AppConfig.prototype.isAppPublic = function() {
      return _pvts[this._idx].app.isAppPublic();
    };

    /**
        Sets the privacy of the application to public.
        @instance
        @method makePublic
        @memberOf AppConfig
        @param {errorCallback} callback
    */


    AppConfig.prototype.makePublic = function(callback) {
      callback = callback || (function() {});
      return this._call('makePublic', callback);
    };

    /**
        Sets the privacy of the application to private.
        @instance
        @method makePrivate
        @memberOf AppConfig
        @param {errorCallback} callback
    */


    AppConfig.prototype.makePrivate = function(callback) {
      callback = callback || (function() {});
      return this._call('makePrivate', callback);
    };

    /**
        Checks if the authentication interface has been enabled.
        @instance
        @method isAuthConfigured
        @memberOf AppConfig
        @return {Bool}
    */


    AppConfig.prototype.isAuthConfigured = function() {
      return _pvts[this._idx].app.isAuthConfigured();
    };

    /**
        Enables the authentication interface.
        @instance
        @method enableAuthentication
        @memberOf AppConfig
        @param {errorCallback} callback
    */


    AppConfig.prototype.enableAuthentication = function(callback) {
      callback = callback || (function() {});
      return this._call('enableAuthentication', callback);
    };

    /**
        Disables the authentication interface.
        @instance
        @method disableAuthentication
        @memberOf AppConfig
        @param {errorCallback} callback
    */


    AppConfig.prototype.disableAuthentication = function(callback) {
      callback = callback || (function() {});
      return this._call('disableAuthentication', callback);
    };

    /**
        Gets the instantiation strategy configured in the app_config.json file.
        @instance
        @method getInstantiationStrategy
        @memberOf AppConfig
        return {String}
    */


    AppConfig.prototype.getInstantiationStrategy = function() {
      return _pvts[this._idx].app.getInstantiationStrategy();
    };

    /**
        Gets the browser limit configured in the
        deployment_config.json file.
        @instance
        @method getBrowserLimit
        @memberOf AppConfig
        return {Number}
    */


    AppConfig.prototype.getBrowserLimit = function() {
      return _pvts[this._idx].app.getBrowserLimit();
    };

    /**
        Sets the browser limit in the
        deployment_config.json file.
        @instance
        @method setBrowserLimit
        @memberOf AppConfig
        @param {Number} limit 
        @param {errorCallback} callback
    */


    AppConfig.prototype.setBrowserLimit = function(limit, callback) {
      if (typeof limit !== "number") {
        if (typeof callback === "function") {
          callback(cloudbrowserError('PARAM_MISSING', '- limit'));
        }
      }
      callback = callback || (function() {});
      return this._call('setBrowserLimit', callback, limit);
    };

    /**
        Mounts the routes for the application
        @instance
        @method mount
        @memberOf AppConfig
        @param {errorCallback} callback
    */


    AppConfig.prototype.mount = function(callback) {
      callback = callback || (function() {});
      return this._call('mount', callback);
    };

    /**
        Unmounts the routes for the application
        @instance
        @method disable
        @memberOf AppConfig
        @param {errorCallback} callback
    */


    AppConfig.prototype.disable = function(callback) {
      callback = callback || (function() {});
      return this._call('disable', callback);
    };

    /**
        Gets a list of all the registered users of the application. 
        @instance
        @method getUsers
        @memberOf AppConfig
        @param {userListCallback} callback
    */


    AppConfig.prototype.getUsers = function(callback) {
      var User, app, cbCtx, userCtx, _ref;
      if (typeof callback !== "function") {
        return;
      }
      _ref = _pvts[this._idx], app = _ref.app, cbCtx = _ref.cbCtx, userCtx = _ref.userCtx;
      if (!app.isAuthConfigured()) {
        return;
      }
      if (userCtx.getNameSpace() === "public") {
        return;
      }
      User = cbCtx.app.User;
      return Async.waterfall([
        function(next) {
          return app.getUsers(next);
        }, function(users, next) {
          var user, userList, _i, _len;
          userList = [];
          for (_i = 0, _len = users.length; _i &lt; _len; _i++) {
            user = users[_i];
            userList.push(new User(user.email, user.ns));
          }
          return next(null, userList);
        }
      ], callback);
    };

    /**
        Checks if the routes for the application have been mounted.
        @instance
        @method isMounted
        @memberOf AppConfig
        @param {Bool} isMounted
    */


    AppConfig.prototype.isMounted = function() {
      return _pvts[this._idx].app.isMounted();
    };

    /**
        Creates a new virtual browser instance of this application.    
        @instance
        @method createVirtualBrowser
        @memberOf AppConfig
        @param {virtualBrowserCallback} callback
    */


    AppConfig.prototype.createVirtualBrowser = function(callback) {
      var VirtualBrowser, app, cbCtx, finalCallback, userCtx, _ref;
      _ref = _pvts[this._idx], userCtx = _ref.userCtx, app = _ref.app, cbCtx = _ref.cbCtx;
      VirtualBrowser = require('./virtual_browser');
      finalCallback = function(bserver) {
        return typeof callback === "function" ? callback(null, new VirtualBrowser({
          bserver: bserver,
          userCtx: userCtx,
          cbCtx: cbCtx
        })) : void 0;
      };
      if (userCtx.getNameSpace() === "public") {
        return finalCallback(app.browsers.create());
      } else {
        return Async.waterfall([
          function(next) {
            return app.browsers.create(userCtx.toJson(), next);
          }
        ], function(err, bserver) {
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          } else {
            return finalCallback(bserver);
          }
        });
      }
    };

    /**
        Gets all the instances of the application associated with the given user.
        @instance
        @method getVirtualBrowsers
        @memberOf AppConfig
        @param {instanceListCallback} callback
    */


    AppConfig.prototype.getVirtualBrowsers = function(callback) {
      var VirtualBrowser, app, cbCtx, mountPoint, permissionManager, userCtx, _ref;
      if (typeof callback !== "function") {
        return;
      }
      _ref = _pvts[this._idx], userCtx = _ref.userCtx, app = _ref.app, cbCtx = _ref.cbCtx;
      permissionManager = app.server.permissionManager;
      mountPoint = app.getMountPoint();
      VirtualBrowser = require('./virtual_browser');
      return Async.waterfall([
        function(next) {
          return permissionManager.getBrowserPermRecs({
            user: userCtx.toJson(),
            mountPoint: mountPoint,
            callback: next
          });
        }, function(browserRecs, next) {
          var browserRec, browsers, id;
          browsers = [];
          for (id in browserRecs) {
            browserRec = browserRecs[id];
            browsers.push(new VirtualBrowser({
              bserver: app.browsers.find(id),
              userCtx: userCtx,
              cbCtx: cbCtx
            }));
          }
          return next(null, browsers);
        }
      ], callback);
    };

    /**
        Registers a listener for an event on an application.
        @instance
        @method addEventListener
        @memberOf AppConfig
        @param {String} event 
        @param {instanceCallback} callback
    */


    AppConfig.prototype.addEventListener = function(event, callback) {
      var VirtualBrowser, app, cbCtx, mountPoint, permissionManager, userCtx, validEvents, _ref;
      if (typeof callback !== "function") {
        return;
      }
      validEvents = ['add', 'remove'];
      if (validEvents.indexOf(event) === -1) {
        return;
      }
      _ref = _pvts[this._idx], userCtx = _ref.userCtx, cbCtx = _ref.cbCtx, app = _ref.app;
      permissionManager = app.server.permissionManager;
      mountPoint = app.getMountPoint();
      VirtualBrowser = require('./virtual_browser');
      return Async.waterfall([
        function(next) {
          return permissionManager.findAppPermRec({
            user: userCtx.toJson(),
            mountPoint: mountPoint,
            callback: next
          });
        }, function(appRec, next) {
          if (appRec) {
            return permissionManager.checkPermissions({
              user: userCtx.toJson(),
              mountPoint: mountPoint,
              permissions: {
                own: true
              },
              callback: function(err, isOwner) {
                return next(err, isOwner, appRec);
              }
            });
          }
        }, function(isOwner, appRec, next) {
          var context, method;
          if (isOwner) {
            method = app.addEventListener;
            context = app;
          } else {
            method = appRec.browsers.on;
            context = appRec.browsers;
          }
          switch (event) {
            case "add":
              return method.call(context, event, function(id) {
                return next(null, new VirtualBrowser({
                  bserver: app.browsers.find(id),
                  userCtx: userCtx,
                  cbCtx: cbCtx
                }));
              });
            default:
              return method.call(context, event, function(arg) {
                return next(null, arg);
              });
          }
        }
      ], function(err, info) {
        if (err) {
          return console.log(err);
        } else {
          return callback(info);
        }
      });
    };

    /**
        Checks if a user is already registered/signed up with the application.
        @instance
        @method isUserRegistered
        @memberOf AppConfig
        @param {User} user
        @param {booleanCallback} callback
    */


    AppConfig.prototype.isUserRegistered = function(user, callback) {
      var app;
      if (typeof callback !== "function") {
        return;
      }
      app = _pvts[this._idx].app;
      return Async.waterfall([
        function(next) {
          return app.findUser(user.toJson(), next);
        }, function(user, next) {
          if (user) {
            return next(null, true);
          } else {
            return next(null, false);
          }
        }
      ], callback);
    };

    /**
        Creates sharable application state
        @instance
        @method createSharedState
        @memberOf AppConfig
        @param {sharedStateCallback} callback
    */


    AppConfig.prototype.createSharedState = function(callback) {
      var app, cbCtx, permissionManager, userCtx, _ref;
      _ref = _pvts[this._idx], app = _ref.app, cbCtx = _ref.cbCtx, userCtx = _ref.userCtx;
      permissionManager = app.server.permissionManager;
      return Async.waterfall([
        function(next) {
          return permissionManager.checkPermissions({
            user: userCtx.toJson(),
            mountPoint: app.getMountPoint(),
            permissions: {
              createSharedState: true
            },
            callback: next
          });
        }, function(canCreate, next) {
          if (!canCreate) {
            return next(cloudbrowserError("PERM_DENIED"));
          } else {
            return app.sharedStates.create(userCtx.toJson(), next);
          }
        }
      ], function(err, sharedState) {
        if (err) {
          return typeof callback === "function" ? callback(err) : void 0;
        } else {
          return callback(null, new SharedState({
            sharedState: sharedState,
            userCtx: userCtx,
            cbCtx: cbCtx,
            app: app
          }));
        }
      });
    };

    /**
        Gets the registered name of the shared state template
        for the current application
        @instance
        @method getSharedStateName
        @memberOf AppConfig
        @returns {string}
    */


    AppConfig.prototype.getSharedStateName = function() {
      return _pvts[this._idx].app.getSharedStateName();
    };

    return AppConfig;

  })();

  module.exports = AppConfig;

}).call(this);
</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					
		<span class="copyright">
		DocStrap Copyright © 2012-2013 The contributors to the JSDoc3 and DocStrap projects.
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a>
		on Wed Sep 18 2013 13:57:07 GMT-0400 (EDT) using the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	

</body>
</html>
